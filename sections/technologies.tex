\section{React}
\setauthor{Michael Ruep}

\section{Spring Boot and Kotlin}
\setauthor{Michael Stenz}
For the backend logic, we had to use Spring Boot, because Spring boot is in the main Stack of Solvistas, and the project should later be maintainable by Solvistas developers. The problems, that our backend had to solve were: handling the storing of the Seatplan metadata, converting the SVG's into image tiles, uploading the converted tiles to an S3 bucket, and serving all of this data to our frontend via REST. For the converting, resizing and slicing of the SVG's and PNG's, we considered Python as an alternative, because there are lots of easy to use and well documented image manipulation libraries like CairoSVG or the OpenCV python wrapper, but the processing of the images is also possible within Java/Kotlin with libraries like Batik and ImageIO, but it's not as straight forward as in python because it's not as popular and therefore there's a lot less documentation, and there are other limitations like heap size always have to be kept in mind. As for the uploading the files to an S3 Bucket, Amazaon provides good support for Java and Kotlin with their S3 SDK for Java/Kotlin and also has lots of documentation and examples all the operations with the S3 buckets. In the end we went with Spring boot and Kotlin because of our proficiency and expertise with the language, and all the other components of the Ticketing software were also written in Spring Boot.

As for the language we used Kotlin in Spring boot even though it's not used in many of Solvistas projects. We still decided that Kotlin was the better option because it is a modern language that is fully interoperable with Java and has many features that make it easier to write clean and concise code, thus reducing errors, improving readability and maintainability. It eliminates much of the boilerplate code required in Java and provides a rich standard library with many built-in utility functions, significantly reducing development time. Kotlin has no essential functionalities that java couldn't provide, but it is more modern and has a more concise syntax. TODO: Da a bissi mehr schreibi so kotlin vs java ka

\section{Database}
\setauthor{Michael Stenz}
We chose PostgreSQL as our database for several key reasons. First, we required a relational database since our data follows a structured design that is best represented through classical relational models. Additionally, using a relational database simplifies the process of exporting generated data into the Ticketing database, which also adheres to a relational structure.

Our system is designed to be compatible with multiple relational databases, not just PostgreSQL, as we utilize Java Persistence API (JPA) as our Object-Relational Mapping (ORM) framework. To maintain database flexibility, we deliberately avoided PostgreSQL-specific commands. While leveraging PL/pgSQL for business logic could have provided benefits such as enhanced security, improved performance, and greater data consistency, we prioritized keeping our database implementation interchangeable.

For database connectivity in our Spring Boot application, we utilized the Spring Data JPA library. This library streamlines the process of connecting to a database and executing queries while implementing the repository pattern. Through this pattern, we define custom queries in an interface, which Spring Boot automatically implements at runtime. This approach simplifies query management, making it easier to maintain and use repository methods directly within our codebase.

To manage database migrations efficiently, we adopted the Flyway library. Flyway enables us to define database changes through SQL scripts that execute automatically when the application starts. This ensures our database schema remains consistent with the latest changes, significantly simplifying deployment and mitigating potential conflicts across different environments. Managing migrations this way also helps prevent issues arising from different database versions among team members. Additionally, since Flyway migrations consist of entire SQL scripts, we can execute both Data Definition Language (DDL) and Data Manipulation Language (DML) commands. This capability is particularly beneficial for tasks such as migrating data between tables, altering column data types, and implementing other business logic-related transformations.

When selecting a migration tool, we evaluated both Liquibase and Flyway. While both are open-source and provide seamless integration with Spring Boot and other Java frameworks, we ultimately opted for Flyway due to its simplicity and our specific use case. Since we are a small team with infrequent parallel database changes, Flyway’s linear migration approach suits our workflow without introducing complications. Although this approach might present challenges in larger teams with concurrent database modifications, it remains a practical choice for our current needs.

Flyway also offers a cleaner versioning system by requiring migration filenames to follow a structured naming convention: \texttt{VX.X.X\_\_migration\_name.sql} (where X.X.X is the version of the migration). In contrast, Liquibase utilizes changelog files, which provide additional features but introduce unnecessary complexity for our use case. These changelog files can be written in SQL, XML, YAML, or JSON, but they require extensive Liquibase-specific formatting. The following example illustrates a Liquibase-formatted SQL changelog file \ref{lst:liquibase:example}. Flyway's approach, which relies on plain SQL migration files, makes it more readable and easier to maintain.

\begin{lstlisting}[language=Sql,caption=Liquibase example changelog,label=lst:liquibase:example]
    --liquibase formatted sql
    
    --changeset nvoxland:1
    create table test1 (  
        id int primary key,
        name varchar(255)  
    );  
    --rollback drop table test1; 
    
    --changeset nvoxland:2 
    insert into test1 (id, name) values (1, 'name 1');
    insert into test1 (id,  name) values (2, 'name 2');  
    
    --changeset nvoxland:3 dbms:oracle
    create sequence seq_test;
\end{lstlisting}
    
To ensure database consistency, Flyway generates a flyway\_schema\_history table that tracks all executed migrations. This table stores metadata for each migration, including the version, description, execution timestamp, and a checksum. The checksum prevents modifications to previously applied migrations, ensuring consistency but potentially causing unexpected errors during local development. In such cases, manual intervention in the flyway\_schema\_history table may be required, but except for these rare cases the flyway\_schema\_history table should not be manipulated manually.

By maintaining this history, Flyway can determine which migrations have been applied and which are still pending. Each migration also has a state, which can be pending, applied, failed, undone, and more—detailed in the Flyway documentation. These states allow system administrators to quickly identify and resolve migration and deployment issues.

When considering how to store our image data, we evaluated PostgreSQL’s built-in options, including BLOBs (Binary Large Objects) and TOAST (The Oversized-Attribute Storage Technique). While these mechanisms allow PostgreSQL to handle large binary files, we ultimately decided against using them due to performance concerns, maintenance overhead, scalability limitations and company reasons.
Even though, TOAST is very performant and automatically compresses and stores large column values outside the main table structure, making it a more attractive option than traditional BLOBs, accessing and manipulating the stored images via SQL queries can become a bottleneck. ORMs like Hibernate tend to retrieve large column values by default unless explicitly configured otherwise, potentially leading to performance degradation when dealing with frequent queries. This means extra effort would be required to optimize database queries to avoid unnecessary data retrieval, increasing development complexity.



\section{AWS}
\setauthor{Michael Stenz}

\section{Leaflet}
\setauthor{Michael Ruep}