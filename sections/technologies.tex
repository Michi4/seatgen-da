\section{React}
\setauthor{Michael Ruep}

\section{Spring Boot and Kotlin}
\setauthor{Michael Stenz}
For the backend logic, we had to use Spring Boot, because Spring boot is in the main Stack of Solvistas, and the project should later be maintainable by Solvistas developers. The problems, that our backend had to solve were: handling the storing of the Seatplan metadata, converting the SVG's into image tiles, uploading the converted tiles to an S3 bucket, and serving all of this data to our frontend via REST. For the converting, resizing and slicing of the SVG's and PNG's, we considered Python as an alternative, because there are lots of easy to use and well documented image manipulation libraries like CairoSVG or the OpenCV python wrapper, but the processing of the images is also possible within Java/Kotlin with libraries like Batik and ImageIO, but it's not as straight forward as in python because it's not as popular and therefore there's a lot less documentation, and there are other limitations like heap size always have to be kept in mind. As for the uploading the files to an S3 Bucket, Amazaon provides good support for Java and Kotlin with their S3 SDK for Java/Kotlin and also has lots of documentation and examples all the operations with the S3 buckets. In the end we went with Spring boot and Kotlin because of our proficiency and expertise with the language, and all the other components of the Ticketing software were also written in Spring Boot.

As for the language we used Kotlin in Spring boot even though it's not used in many of Solvistas projects. We still decided that Kotlin was the better option because it is a modern language that is fully interoperable with Java and has many features that make it easier to write clean and concise code, thus reducing errors, improving readability and maintainability. It eliminates much of the boilerplate code required in Java and provides a rich standard library with many built-in utility functions, significantly reducing development time. Kotlin has no essential functionalities that java couldn't provide, but it is more modern and has a more concise syntax. TODO: Da a bissi mehr schreibi so kotlin vs java ka

\section{Database}
\setauthor{Michael Stenz}
We chose PostgreSQL as our database for several key reasons. First, we needed a relational database because our data follows a structured design that is best represented through classic relations. Additionally, we wanted to simplify the process of exporting generated data into the Ticketing database, which is also relational.

Our system is designed to work with multiple relational databases, not just PostgreSQL, as we use JPA as our ORM. To maintain database flexibility, we deliberately avoided PostgreSQL-specific commands. While using PL/pgSQL for business logic could have improved security, performance, and data consistency, we prioritized keeping our database easily interchangeable.

For the database connection in our Spring Boot application, we used the Spring Data JPA library. This library simplifies the process of connecting to a database and executing queries. It also provides a repository pattern that allows us to define custom queries in an interface, which Spring Boot automatically implements at runtime. This pattern makes it easy to write and maintain queries, as we can use the repository methods directly in our code. We also use the Flyway library to manage database migrations. Flyway allows us to define database changes as SQL scripts, which are executed automatically when the application starts. This ensures that our database schema is always up-to-date with the latest changes. Doing migrations this way simplifies the deployment process drastically and helps avoid conflicts in the deployment and on the local production environment. Another advantage of using Flyway database migrations instead of migrating the database by hand, is that other developers in the team don't run into unexpected errors because of different database versions, and because migrations consist of whole SQL scripts, we have the possibility to not only execute DDL (Data Definition Language) commands but also DML (Data Manipulation Language) commands, which can be useful in a lot of scenarios, for example when migrating data from one table to another, changing the data type of column, and applying other business logic on data in the tables. We had to decide between Liquibase and Flyway for the database migrations. Both tools are very similar in a lot of aspects. They are both open source, both provide support for Spring Boot and other Java frameworks. The key differences are very subtle for out use case which does not need any complex features. We decided to go with Flyway because we do not need the more features and flexibility that Liquibase provides. Because we are a small team and changes on the database don't happen often in parallel, we have no problem with using Flyway's linear database migration approach, even though it could lead to problems in bigger teams with more parallel changes on the database. Flyway's versioning is also cleaner because the filenames of the migrations have to start with a specific prefix that contains the version of the migration in the following form \texttt{VX.X.X\_\_migration\_name.sql} (where X.X.X is the version of the migration). On the other hand Liquibase stores its changes in changelog files, this would allow a lot more features but also comes with a lot of unnecessary complexity. A changelog file can be written in SQL, XML, YAML, or JSON formats, but comments there is a lot of overhead and unnecessary metadata that has to be specified as seen in 

\section{AWS}
\setauthor{Michael Stenz}

\section{Leaflet}
\setauthor{Michael Ruep}