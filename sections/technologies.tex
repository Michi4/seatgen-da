\section{React}
\setauthor{Michael Ruep}
The frontend of SeatGen is built using the React framework. This choice was primarily motivated by the existing expertise within Solvistas, ensuring that the company’s developers could easily maintain and adjust the project to their needs. Additionally, React provides an ideal balance between flexibility, performance, and a vibrant ecosystem, which are factors that proved crucial when building an interactive seating plan editor for stadiums. Also, our team was already experienced with component-based single page application frontend frameworks.

\subsection{Framework Background}
React is an open-source JavaScript library developed and maintained by Meta (formerly known as Facebook) and a community of individual developers and companies. Originally introduced in 2013 to power Facebook’s dynamic news feed, React has since become renowned for creating data-driven web interfaces~\cite{ReactDocs, SPAComp}. Rather than manually manipulating the Document Object Model (DOM), developers can simply declare how the interface should appear based on the underlying data. This declarative approach allows React to handle updates internally, ensuring smoother user interactions, which are especially beneficial for large or frequently changing data sets~\cite{ReactVirtualDOM, SPAComp}.

\subsection{Virtual DOM}
\setauthor{Michael Ruep}
React’s Virtual DOM architecture is particularly advantageous for applications requiring frequent updates and complex UI interactions. In SeatGen, each seat on the map can be added, moved, or deleted in real time, causing rapid changes that must be reflected in the user interface without compromising speed. By selectively re-rendering only components that have actually changed, the Virtual DOM mechanism helps maintain excellent performance even under heavy load~\cite{ReactVirtualDOM}. This aligns with the findings in~\cite{SPAComp}, where React demonstrates superior rendering speed and user satisfaction in Single Page Applications (SPAs) requiring dynamic content updates.

\subsection{Component-based Architecture}
\setauthor{Michael Ruep}
TODO: numoi drüber lesen auf süß
React’s component-based architecture keeps each feature modular and make the project easier to maintain as it grows. Instead of bundling all functionality into a single monolithic view, UI features are developed as self-contained components. In our case for example:
\begin{compactitem}
    \item Seat map interface
    \item Toolbar actions
    \item Detail panels
\end{compactitem}
Each of those elements have their own modules, allowing developers to modify or expand individual features without affecting unrelated parts of the application. This approach simplifies debugging, since issues can often be traced to a specific component rather than across the entire codebase. It is also suitable for collaborative development by letting team members work on separate components in parallel, which significantly accelerated our development process. Overall, React’s modular design reduces complexity which assists a more organized and maintainable codebase.
~\cite{ReactCBA01, ReactCBA02, ReactCBA03}

\section{Spring Boot and Kotlin}
\setauthor{Michael Stenz}
For the backend logic, we chose Spring Boot as it is a core technology in Solvistas’ tech stack. This decision ensures that the project remains maintainable by Solvistas developers in the long run. Our backend had several key responsibilities, including:
\begin{compactitem}
    \item Handling the storage of the seatplan metadata
    \item Converting SVGs into image tiles
    \item Uploading the converted tiles to an S3 bucket
    \item Serving all of this data to the frontend via REST
\end{compactitem}

For image processing tasks such as resizing and slicing SVGs and PNGs, we initially considered Python due to its well-documented and easy-to-use image manipulation libraries like CairoSVG and OpenCV. However, we ultimately decided to keep the processing within the Java/Kotlin ecosystem, using libraries like Batik and ImageIO. While Java/Kotlin image processing is not as straightforward as Python due to less extensive documentation and fewer community resources, it allowed us to keep our backend technology stack consistent. Additionally, using Java/Kotlin ensured we did not need to manage separate runtime environments. One challenge with Java-based image processing is memory management—heap size and garbage collection must always be considered, especially when processing large images.

For file uploads, Amazon S3 provides excellent support for Java and Kotlin through the AWS SDK, with extensive documentation and examples. This made it easy to integrate S3 into our backend for storing and retrieving image tiles efficiently.

As for the language, we used Kotlin in Spring Boot even though it’s not used in many of Solvistas’ projects. We still decided that Kotlin was the better option because it is a modern language that is fully interoperable with Java and has many features that make it easier to write clean and concise code, thus reducing errors, improving readability, and maintainability. It eliminates much of the boilerplate code required in Java and provides a rich standard library with many built-in utility functions, significantly reducing development time. Kotlin has no essential functionalities that Java couldn’t provide, but it is more modern and has a more concise syntax.

Additionally, Kotlin introduces powerful features such as null safety, which helps create more robust applications with fewer runtime errors. Furthermore, Kotlin provides strong support for functional programming, including higher-order functions, lambda expressions, and extension functions, making it easier to write expressive and reusable code.

Another key advantage is Kotlin’s coroutines, which allow for highly efficient asynchronous programming without the complexity of Java’s traditional thread management. This makes Kotlin particularly well-suited for handling concurrent tasks, such as processing multiple image transformations simultaneously which reduces our image processing time by a factor a lot.

Kotlin’s seamless integration with Spring Boot also allows for idiomatic DSLs (Domain-Specific Languages), which can simplify configuration and reduce verbosity in code. The language’s structured concurrency and intuitive syntax contribute to cleaner, more maintainable backend services, ensuring long-term scalability.

Finally, Kotlin’s growing adoption within the Spring ecosystem, along with first-class support from JetBrains and the Spring team, makes it a viable choice for modern backend development. Its developer-friendly nature, combined with reduced verbosity and enhanced safety features, makes it a forward-thinking investment despite its lower adoption within Solvistas’ existing projects.

In the end, we chose Spring Boot with Kotlin because of our team’s expertise with the language and the fact that all other components of the Ticketing software were already written in Spring Boot.

\section{Database}
\setauthor{Michael Stenz}
We chose PostgreSQL as our database for several key reasons. First, we required a relational database since our data follows a structured design that is best represented through classical relational models. Additionally, using a relational database simplifies the process of exporting generated data into the Ticketing database, which also adheres to a relational structure.

Our system is designed to be compatible with multiple relational databases, not just PostgreSQL, as we utilize Java Persistence API (JPA) as our Object-Relational Mapping (ORM) framework. To maintain database flexibility, we deliberately avoided PostgreSQL-specific commands. While leveraging PL/pgSQL for business logic could have provided benefits such as enhanced security, improved performance, and greater data consistency, we prioritized keeping our database implementation interchangeable.

For database connectivity in our Spring Boot application, we utilized the Spring Data JPA library. This library streamlines the process of connecting to a database and executing queries while implementing the repository pattern. Through this pattern, we define custom queries in an interface, which Spring Boot automatically implements at runtime. This approach simplifies query management, making it easier to maintain and use repository methods directly within our codebase.

To manage database migrations efficiently, we adopted the Flyway library. Flyway enables us to define database changes through SQL scripts that execute automatically when the application starts. This ensures our database schema remains consistent with the latest changes, significantly simplifying deployment and mitigating potential conflicts across different environments. Managing migrations this way also helps prevent issues arising from different database versions among team members. Additionally, since Flyway migrations consist of entire SQL scripts, we can execute both Data Definition Language (DDL) and Data Manipulation Language (DML) commands. This capability is particularly beneficial for tasks such as migrating data between tables, altering column data types, and implementing other business logic-related transformations.

When selecting a migration tool, we evaluated both Liquibase and Flyway. While both are open-source and provide seamless integration with Spring Boot and other Java frameworks, we ultimately opted for Flyway due to its simplicity and our specific use case. Since we are a small team with infrequent parallel database changes, Flyway’s linear migration approach suits our workflow without introducing complications. Although this approach might present challenges in larger teams with concurrent database modifications, it remains a practical choice for our current needs.

Flyway also offers a cleaner versioning system by requiring migration filenames to follow a structured naming convention: \texttt{VX.X.X\_\_migration\_name.sql} (where X.X.X is the version of the migration). In contrast, Liquibase utilizes changelog files, which provide additional features but introduce unnecessary complexity for our use case. These changelog files can be written in SQL, XML, YAML, or JSON, but they require extensive Liquibase-specific formatting. The following example illustrates a Liquibase-formatted SQL changelog file \ref{lst:liquibase:example}. Flyway’s approach, which relies on plain SQL migration files, makes it more readable and easier to maintain.

\begin{lstlisting}[language=Sql,caption=Liquibase example changelog,label=lst:liquibase:example]
    --liquibase formatted sql
    
    --changeset nvoxland:1
    create table test1 (  
        id int primary key,
        name varchar(255)  
    );  
    --rollback drop table test1; 
    
    --changeset nvoxland:2 
    insert into test1 (id, name) values (1, 'name 1');
    insert into test1 (id,  name) values (2, 'name 2');  
    
    --changeset nvoxland:3 dbms:oracle
    create sequence seq_test;
\end{lstlisting}
    
To ensure database consistency, Flyway generates a flyway\_schema\_history table that tracks all executed migrations. This table stores metadata for each migration, including the version, description, execution timestamp, and a checksum. The checksum prevents modifications to previously applied migrations, ensuring consistency but potentially causing unexpected errors during local development. In such cases, manual intervention in the flyway\_schema\_history table may be required, but except for these rare cases the flyway\_schema\_history table should not be manipulated manually.

By maintaining this history, Flyway can determine which migrations have been applied and which are still pending. Each migration also has a state, which can be pending, applied, failed, undone, and more—detailed in the Flyway documentation. These states allow system administrators to quickly identify and resolve migration and deployment issues.

When considering how to store our image data, we evaluated PostgreSQL’s built-in options, including BLOBs (Binary Large Objects) and TOAST (The Oversized-Attribute Storage Technique). While these mechanisms allow PostgreSQL to handle large binary files, we ultimately decided against using them due to performance concerns, maintenance overhead, scalability limitations and company reasons.
Even though, TOAST is very performant and automatically compresses and stores large column values outside the main table structure, making it a more attractive option than traditional BLOBs, accessing and manipulating the stored images via SQL queries can become a bottleneck. ORMs like Hibernate tend to retrieve large column values by default unless explicitly configured otherwise, potentially leading to performance degradation when dealing with frequent queries. This means extra effort would be required to optimize database queries to avoid unnecessary data retrieval, increasing development complexity.


\section{AWS - S3}
\setauthor{Michael Stenz}
Amazon S3 (Simple Storage Service) is a scalable object storage service provided by Amazon Web Services (AWS). It allows users to store and retrieve large amounts of data in the cloud, with a focus on high availability, durability, and security. S3 is widely used for storing static assets such as images, videos, documents, and backups, and it is designed to provide low-latency access to data from anywhere in the world and in our case the image tiles of the seatplan. With features such as data encryption, versioning, and lifecycle policies, S3 offers a flexible and cost-effective solution for managing large datasets. S3 also provides an extensive API that allows developers to interact with their storage buckets programmatically. In this application we access the API via the AWS SDK for Java which is provided and maintained by Amazon.

In the Ticketing project, all image tiles are stored in an AWS S3 bucket. S3 was required due to its robust performance, reliability, and seamless integration with the AWS ecosystem, which is already in use at Solvistas. By utilizing the Amazon S3 SDK, the file upload process is automated, reducing manual effort and minimizing the risk of errors.

Using S3 also improves frontend performance by ensuring that image retrieval does not depend on the backend server’s speed. Instead of acting as a middleware for serving images, the backend delegates this task directly to S3, reducing its workload and enhancing response times.

AWS S3 was the only option considered, as it is the cloud platform used by Solvistas, and the infrastructure costs are funded by the company.


\section{Leaflet}
\setauthor{Michael Ruep}