A complete visualization of the tech stack can be found in \ref{fig:tech-stack}. Further details and explanations can be found in the following sections.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{pics/tech-stack.png}
    \caption{Tech Stack}
    \label{fig:tech-stack}
\end{figure}


\section{React}
\setauthor{Michael Ruep}

\section{Spring Boot and Kotlin}
\setauthor{Michael Stenz}
For the backend logic, Spring Boot was chosen as it is a core technology in Solvistas' tech stack. This decision ensures that the project remains maintainable by Solvistas developers in the long run. The backend has several key responsibilities, including:\begin{compactitem}
    \item Handling the storage of the seatplan metadata
    \item Converting SVGs into image tiles
    \item Uploading the converted tiles to an S3 bucket
    \item Serving all of this data to the frontend via REST
\end{compactitem}

For image processing tasks such as resizing and slicing SVGs and PNGs, Python was initially considered due to its well-documented and easy-to-use image manipulation libraries like CairoSVG and OpenCV. However, the decision was ultimately made to keep the processing within the Java/Kotlin ecosystem, using libraries like Batik\cite{BatikDocs} and ImageIO\cite{JavaImageIODocs}. While Java/Kotlin image processing is not as straightforward as Python due to less extensive documentation and fewer community resources, this choice allowed for a consistent backend technology stack. One challenge with Java-based image processing is memory management—heap size and garbage collection must always be considered, especially when processing large images. For file uploads, Amazon S3 provides excellent support for Java and Kotlin through the AWS SDK\cite{AWSKotlinSDK}, accompanied by extensive documentation and examples. This integration made it easy to incorporate S3 into the backend for efficiently storing and retrieving image tiles.

\subsection{Kotlin}
As for the language, Kotlin was used in Spring Boot, even though it is not commonly employed in many of Solvistas' projects. However, Kotlin was deemed the better option because it is a modern language that is fully interoperable with Java and offers many features that facilitate writing clean and concise code, thereby reducing errors and improving readability and maintainability. It eliminates much of the boilerplate code required in Java and provides a rich standard library with numerous built-in utility functions, significantly reducing development time. While Kotlin does not offer essential functionalities that Java cannot provide, it is more modern and has a more concise syntax.

Additionally, Kotlin introduces powerful features such as null safety, which helps create more robust applications with fewer runtime errors. Furthermore, Kotlin provides strong support for functional programming, including higher-order functions, lambda expressions, and extension functions, making it easier to write expressive and reusable code. Another key advantage is Kotlin’s coroutines, which enable highly efficient asynchronous programming without the complexity of Java’s traditional thread management. This makes Kotlin particularly well-suited for handling concurrent tasks, such as processing multiple image transformations simultaneously, significantly reducing processing time.

Kotlin’s seamless integration with Spring Boot also allows for idiomatic DSLs (Domain-Specific Languages), which can simplify configuration and reduce verbosity in code. The language’s structured concurrency and intuitive syntax contribute to cleaner, more maintainable backend services, ensuring long-term scalability. Finally, Kotlin’s growing adoption within the Spring ecosystem, along with first-class support from JetBrains and the Spring team, makes it a viable choice for modern backend development. Its developer-friendly nature, combined with reduced verbosity and enhanced safety features, positions it as a forward-thinking investment despite its lower adoption within Solvistas' existing projects.

In the end, Spring Boot with Kotlin was chosen due to the team's expertise with the language and the fact that all other components of the Ticketing software were already written in Spring Boot.

\subsection{API Documentation with Swagger}
SeatGen also utilizes SwaggerUi and SwaggerUi codegen to generate REST API documentation and client code for the frontend. This allows for easy integration of the backend with the frontend and ensures that the frontend developers always have the most up-to-date API documentation. This is done via the OpenApi gradlew plugin, which generates the SwaggerUi documentation and client code for all the API endpoints and required models. The generated docs can be fetched by the frontend developers with a script within the \texttt{package.json} file, under the name \texttt{fetch-openapi-docs}. This script fetches the api-docs.yaml file from the backend and saves it in the frontend project. When starting or building the frontend, the \texttt{swagger-typescript-api} plugin generates the client code from this file. The frontend developer now can use the generated client code to interact with the backend API through the generated functions and models without having to manually maintain the API client code.


\section{Database}
\setauthor{Michael Stenz}
PostgreSQL was chosen as the database for several key reasons. A relational database is required since the data follows a structured design that is best represented through classical relational models. The structure of the database is visualized in the class diagram \ref{fig:db_model}. Additionally, utilizing a relational database simplifies the process of exporting generated data into the Ticketing database, which also adheres to a relational structure.

\begin{figure}
    \centering
    \includegraphics[scale=0.5]{pics/db_model.png}
    \caption{Database Model}
    \label{fig:db_model}
\end{figure}

The system is designed to be compatible with multiple relational databases, not just PostgreSQL, as the Java Persistence API (JPA) is utilized as the Object-Relational Mapping (ORM) framework. To maintain database flexibility, PostgreSQL-specific commands were deliberately avoided. While leveraging PL/pgSQL for business logic could have provided benefits such as enhanced security, improved performance, and greater data consistency, database interchangeability was prioritized.

For database connectivity in the Spring Boot application, the Spring Data JPA library was utilized. This library streamlines the process of connecting to a database and executing queries while implementing the repository pattern. Through this pattern, custom queries are defined in an interface, which Spring Boot automatically implements at runtime. This approach simplifies query management, making it easier to maintain and use repository methods directly within the codebase.

To manage database migrations efficiently, the Flyway \cite{FlywayDocs} library is used. Flyway enables the to define database changes through SQL scripts that execute automatically when the application starts. This ensures that the database schema remains consistent with the latest changes, simplifying deployment and mitigating potential conflicts across different environments. Managing migrations this way also helps prevent issues arising from different database versions among team members. Additionally, since Flyway migrations consist of entire SQL scripts, both Data Definition Language (DDL) and Data Manipulation Language (DML) commands can be executed. This capability is particularly beneficial for tasks such as migrating data between tables, altering column data types, and implementing other business logic-related transformations.

When selecting a migration tool, both Liquibase \cite{LiquibaseDocs} and Flyway were evaluated. While both are open-source and provide seamless integration with Spring Boot and other Java frameworks, the decision was ultimately made to opt for Flyway due to its simplicity and specific use case. Since the team is small with infrequent parallel database changes, Flyway’s linear migration approach suits the workflow without introducing complications. Although this approach might present challenges in larger teams with concurrent database modifications, it remains a practical choice for current needs.

Flyway also offers a cleaner versioning system by requiring migration filenames to follow a structured naming convention: \texttt{VX.X.X\_\_migration\_name.sql} (where X.X.X is the version of the migration). In contrast, Liquibase utilizes changelog files, which provide additional features but introduce unnecessary complexity for the use case. These changelog files can be written in SQL, XML, YAML, or JSON, but they require extensive Liquibase-specific formatting. The following example illustrates a Liquibase-formatted SQL changelog file \ref{lst:liquibase:example}. Flyway's approach, which relies on plain SQL migration files, enhances readability and maintainability.

\begin{lstlisting}[language=Sql,caption=Liquibase example changelog,label=lst:liquibase:example]
    --liquibase formatted sql
    
    --changeset nvoxland:1
    create table test1 (  
        id int primary key,
        name varchar(255)  
    );  
    --rollback drop table test1; 
    
    --changeset nvoxland:2 
    insert into test1 (id, name) values (1, 'name 1');
    insert into test1 (id,  name) values (2, 'name 2');  
    
    --changeset nvoxland:3 dbms:oracle
    create sequence seq_test;
\end{lstlisting}
    
To ensure database consistency, Flyway generates a flyway\_schema\_history table that tracks all executed migrations. This table stores metadata for each migration, including the version, description, execution timestamp, and a checksum. The checksum prevents modifications to previously applied migrations, ensuring consistency but potentially causing unexpected errors during local development. In such cases, manual intervention in the flyway\_schema\_history table may be required, but except for these rare cases the flyway\_schema\_history table should not be manipulated manually.

By maintaining this history, Flyway can determine which migrations have been applied and which are still pending. Each migration also has a state, which can be pending, applied, failed, undone, and more—detailed in the Flyway documentation. These states allow system administrators to quickly identify and resolve migration and deployment issues.

When considering how to store image data, PostgreSQL’s built-in options, including BLOBs (Binary Large Objects) and TOAST \cite{PostgreSQLDocs} (The Oversized-Attribute Storage Technique), were evaluated. While these mechanisms allow PostgreSQL to handle large binary files, the decision was ultimately made against using them due to performance concerns, maintenance overhead, scalability limitations, and company reasons.
Even though, TOAST is very performant and automatically compresses and stores large column values outside the main table structure, making it a more attractive option than traditional BLOBs, accessing and manipulating the stored images via SQL queries can become a bottleneck. ORMs like Hibernate tend to retrieve large column values by default unless explicitly configured otherwise, potentially leading to performance degradation when dealing with frequent queries. This means extra effort would be required to optimize database queries to avoid unnecessary data retrieval, increasing development complexity.


\section{AWS - S3}
\setauthor{Michael Stenz}
For image processing tasks such as resizing and slicing SVGs and PNGs, Python was initially considered due to its well-documented and easy-to-use image manipulation libraries like CairoSVG and OpenCV. However, the decision was ultimately made to keep the processing within the Java/Kotlin ecosystem, utilizing libraries such as Batik and ImageIO. While image processing in Java/Kotlin is not as straightforward as in Python due to less extensive documentation and fewer community resources, maintaining consistency within the backend technology stack was prioritized. One challenge associated with Java-based image processing is memory management—heap size and garbage collection must always be considered, especially when processing large images. For file uploads, Amazon S3 provides excellent support for Java and Kotlin through the AWS SDK, with extensive documentation and examples. This facilitated seamless integration of S3 into the backend for efficient storage and retrieval of image tiles.

In the Ticketing project, all image tiles are stored in an AWS S3 bucket. S3 was required due to its robust performance, reliability, and seamless integration with the AWS ecosystem, which is already in use at Solvistas. By utilizing the Amazon S3 SDK, the file upload process is automated, reducing manual effort and minimizing the risk of errors.

Using S3 also improves frontend performance by ensuring that image retrieval does not depend on the backend server’s speed. Instead of acting as a middleware for serving images, the backend delegates this task directly to S3, reducing its workload and enhancing response times.

AWS S3 was the only option considered, as it is the cloud platform used by Solvistas, and the infrastructure costs are funded by the company.

\section{Leaflet}
